import torch
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import pickle
import os
import time

# ADDING CURRENT FOLDER TO THE PATH OF PACKAGES
import sys
sys.path.append(os.getcwd())
from tools.diffusion_model import ConditionalDiffusionModel
from tools.OCP_solving_cpin import solve_DOC

# Parameters
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
TIMESTEPS = 1000
N_SAMPLES = 50      # Number of samples generated by diffusion
MAX_LEN = 50        # Full length of the trajectory
W_DIM = 5           # Dimension of the cost weights

# Generate ground truth weights (test data)
print("Generating Ground Truth trajectory...")

# w of bad case 1
# w_true = np.array([0.35580205, 0.08444934, 0.04894771, 0.97840037, 0.62304979])


# w of bad case 2
w_true = np.array([0.73879914, 0.07483681, 0.1084752,  0.03661114, 0.0412777])

# w_true = np.random.rand(W_DIM)
# w_true = w_true / np.sum(w_true)                                                          # Normalize to sum to 1
print(f"True Weights: {w_true}")

# Train data for some comparison
train_traj = np.load("data/array_results_angles_10000.npy")
w_train = np.load("data/array_w_10000.npy")

try:
    # Generating the ground truth trajectory (q1, q2)
    results_angles, _ = solve_DOC(w_true, x_fin=-1.0, q_init=np.array([0, np.pi/4]))
    traj_true = results_angles # Shape: (50, 2)
except Exception as e:
    print(f"Error solving OCP for ground truth: {e}")
    exit()


distance_array_to_ground_truth = ((train_traj - results_angles)**2).mean(axis=(1,2))
closest_traj_to_ground_truth = np.argmin(distance_array_to_ground_truth)

closest_traj = train_traj[closest_traj_to_ground_truth]
traj_true = closest_traj


# Load Model and Scaler
# print("Loading model and scaler...")
# with open('scaler_w.pkl', 'rb') as f:
#     scaler_w = pickle.load(f)

model = ConditionalDiffusionModel(w_dim=W_DIM).to(DEVICE)
# Load the trained weights
model.load_state_dict(torch.load("diffusion_model.pth", map_location=DEVICE))
model.eval()

# Pre-compute diffusion schedule
beta = torch.linspace(1e-4, 0.02, TIMESTEPS).to(DEVICE)
alpha = 1. - beta
alpha_hat = torch.cumprod(alpha, dim=0)

# Diffusion sampling function
def sample_diffusion(model, condition_trajectory, n_samples):
    """
    Infers weights given a condition trajectory using the diffusion model.
    """
    model.eval()
    with torch.no_grad():
        # Replicate condition for the batch size
        cond_repeated = condition_trajectory.repeat(n_samples, 1, 1)
        
        # Start from pure Gaussian noise
        w_current = torch.randn(n_samples, W_DIM).to(DEVICE)

        # Denoising loop
        # TODO: for earning inference time, should try DDIM instead of DDPM
        for i in reversed(range(TIMESTEPS)):
            t = torch.full((n_samples,), i, device=DEVICE, dtype=torch.long)
            predicted_noise = model(w_current, t, cond_repeated)

            alpha_t = alpha[i]
            alpha_hat_t = alpha_hat[i]
            beta_t = beta[i]

            if i > 0:
                noise = torch.randn_like(w_current)
            else:
                noise = torch.zeros_like(w_current)

            # Reverse diffusion step
            w_current = (1 / torch.sqrt(alpha_t)) * (
                w_current - ((1 - alpha_t) / torch.sqrt(1 - alpha_hat_t)) * predicted_noise
            ) + torch.sqrt(beta_t) * noise

    return w_current

# Prepare Data for Inference
observation_length = MAX_LEN 
sub_traj = traj_true[:observation_length]

# Create padding and mask
# NOTE: here I could try later on shorter prefix, the idea was for now just to compare the recovered trajectories, even if the recovered weights
# are far from the ground truth
padded_traj = np.zeros((MAX_LEN, 2))
padded_traj[:observation_length] = sub_traj
mask = np.zeros((MAX_LEN, 1))
mask[:observation_length] = 1

# Concatenate and convert to tensor
combined = np.concatenate([padded_traj, mask], axis=1)
traj_tensor = torch.FloatTensor(combined).unsqueeze(0).transpose(1, 2).to(DEVICE)

# Run Inference
t_start = time.time()
print("Running diffusion inference...")
generated_w_normalized = sample_diffusion(model, traj_tensor, N_SAMPLES)
t_end = time.time()
print(f"Inference time: {t_end - t_start}")

# ADAPTED FOR WITHOUT SCALER ANALYSIS
# generated_w = scaler_w.inverse_transform(generated_w_normalized.cpu().numpy())
generated_w = generated_w_normalized


# Calculate the MEAN predicted weight
# w_pred_mean = np.mean(generated_w, axis=0)
w_pred_mean = generated_w.detach().cpu().numpy().mean(axis=0)

# Optional: Normalize
# if np.sum(w_pred_mean) > 0:
#     w_pred_mean = w_pred_mean / np.sum(w_pred_mean)

print(f"Predicted Mean Weights: {w_pred_mean}")

# Reconstruct Trajectory
print("Solving OCP with predicted weights to reconstruct trajectory...")
try:
    traj_reconstructed, _ = solve_DOC(w_pred_mean, x_fin=-1.0, q_init=np.array([0, np.pi/4]))
except Exception as e:
    print(f"Error solving OCP for reconstruction: {e}")
    traj_reconstructed = np.zeros_like(traj_true)

# Plotting Results (Separated)
# We create a figure with 3 columns
fig, (ax_w, ax_q1, ax_q2) = plt.subplots(1, 3, figsize=(18, 6))

# Computing the closest trajectory of the dataset
distance_array_to_reconstructed = ((train_traj - traj_reconstructed)**2).mean(axis=(1,2))
closest_traj_to_reconstructed_index = np.argmin(distance_array_to_reconstructed)
# distance_array_to_ground_truth = ((train_traj - results_angles)**2).mean(axis=(1,2))
# closest_traj_to_ground_truth = np.argmin(distance_array_to_ground_truth)

# Plot 1: weights comparison (between ground truth and recovered)
indices = np.arange(W_DIM)
width = 0.2
# ax_w.bar(indices - width/2, w_true, width, label='True Weights', color='black', alpha=0.7)
# ax_w.bar(indices + width/2, w_pred_mean, width, label='Predicted (Mean)', color='orange', alpha=0.7)
ax_w.bar(indices - 3*width/2, w_true, width, label='True Weights', color='black', alpha=0.7)
ax_w.bar(indices - width/2, w_pred_mean, width, label='Predicted (Mean)', color='orange', alpha=0.7)
ax_w.bar(indices + width/2, w_train[closest_traj_to_reconstructed_index], width, label='w of the closest train trajectory to reconstructed', color='red', alpha=0.7)
ax_w.bar(indices + 3*width/2, w_train[closest_traj_to_ground_truth], width, label='w of the closest train trajectory to ground truth', color='green', alpha=0.7)
ax_w.set_ylabel('Weight Value')
ax_w.set_title('Weights Comparison')
ax_w.set_xticks(indices)
ax_w.set_xticklabels([f'w{i+1}' for i in indices])
ax_w.legend()
ax_w.grid(True, linestyle='--', alpha=0.3)

# RMSE between ground truth and recovered
# Convert radians to degrees for error calculation
traj_true_deg = np.degrees(traj_true)
traj_rec_deg = np.degrees(traj_reconstructed)

rmse_q1 = np.sqrt(np.mean((traj_true_deg[:, 0] - traj_rec_deg[:, 0])**2))
rmse_q2 = np.sqrt(np.mean((traj_true_deg[:, 1] - traj_rec_deg[:, 1])**2))

# Plot 2: q1
time_steps = np.arange(MAX_LEN)
# Note: (360/(2*np.pi)) is equivalent to np.degrees()
ax_q1.plot(np.degrees(traj_true[:, 0]), 'k--', linewidth=2, label='q1 True')
ax_q1.plot(np.degrees(traj_reconstructed[:, 0]), 'b-', linewidth=2, alpha=0.8, label='q1 Reconstructed')
ax_q1.plot(np.degrees(train_traj[closest_traj_to_reconstructed_index][:, 0]), 'c:', linewidth=2, alpha=0.8, label='q1 of the closest train trajectory to reconstructed')
ax_q1.plot(np.degrees(train_traj[closest_traj_to_ground_truth][:, 0]), 'm:', linewidth=2, alpha=0.8, label='q1 of the closest train trajectory to ground truth')
ax_q1.set_title('Joint Angle q1 Reconstruction')
ax_q1.set_xlabel('Time Step')
ax_q1.set_ylabel('Angle (deg)') # Changed label to 'deg' as per data conversion
ax_q1.legend()
ax_q1.grid(True, linestyle='--', alpha=0.3)

# RMSE text box in bottom right
ax_q1.text(0.95, 0.05, f'RMSE: {rmse_q1:.2f}°', 
           transform=ax_q1.transAxes, 
           horizontalalignment='right', 
           verticalalignment='bottom',
           fontsize=12,
           bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="black", alpha=0.8))

# Plot 3: q2
ax_q2.plot(np.degrees(traj_true[:, 1]), 'k--', linewidth=2, label='q2 True')
ax_q2.plot(np.degrees(traj_reconstructed[:, 1]), 'r-', linewidth=2, alpha=0.8, label='q2 Reconstructed')
ax_q2.plot(np.degrees(train_traj[closest_traj_to_reconstructed_index][:, 1]), 'y:', linewidth=2, alpha=0.8, label='q2 from closest trajectory of train set')
ax_q2.plot(np.degrees(train_traj[closest_traj_to_ground_truth][:, 1]), 'm:', linewidth=2, alpha=0.8, label='q2 of the closest train trajectory to ground truth')
ax_q2.set_title('Joint Angle q2 Reconstruction')
ax_q2.set_xlabel('Time Step')
ax_q2.set_ylabel('Angle (deg)') # Changed label to 'deg'
ax_q2.legend()
ax_q2.grid(True, linestyle='--', alpha=0.3)

# RMSE text box in bottom right
ax_q2.text(0.95, 0.05, f'RMSE: {rmse_q2:.2f}°', 
           transform=ax_q2.transAxes, 
           horizontalalignment='right', 
           verticalalignment='bottom',
           fontsize=12,
           bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="black", alpha=0.8))

plt.tight_layout()
plt.show()

# Save the figure
fig.savefig("reconstruction_separated_rmse.png")
print("Comparison plot saved as 'reconstruction_separated_rmse.png'")
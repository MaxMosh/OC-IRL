import torch
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import pickle
import os

# ADDING CURRENT FOLDER TO THE PATH OF PACKAGES
import sys
sys.path.append(os.getcwd())
from tools.diffusion_model import ConditionalDiffusionModel
from tools.OCP_solving_cpin import solve_DOC

# --- Parameters ---
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
TIMESTEPS = 1000
N_SAMPLES = 50      # Number of samples generated by diffusion
MAX_LEN = 50        # Full length of the trajectory
W_DIM = 5           # Dimension of the cost weights

# --- 1. Generate Ground Truth (Unseen) Trajectory ---
print("Generating Ground Truth trajectory...")

# Generate random true weights
w_true = np.random.rand(W_DIM)
w_true = w_true / np.sum(w_true) # Normalize to sum to 1
print(f"True Weights: {w_true}")

try:
    # Solve OCP to get the ground truth trajectory
    results_angles, _ = solve_DOC(w_true, x_fin=-1.0, q_init=np.array([0, np.pi/4]))
    traj_true = results_angles # Shape: (50, 2)
except Exception as e:
    print(f"Error solving OCP for ground truth: {e}")
    exit()

# --- 2. Load Model and Scaler ---
print("Loading model and scaler...")
with open('scaler_w.pkl', 'rb') as f:
    scaler_w = pickle.load(f)

model = ConditionalDiffusionModel(w_dim=W_DIM).to(DEVICE)
# Load the trained weights
model.load_state_dict(torch.load("diffusion_model_with_scaler.pth", map_location=DEVICE))
model.eval()

# Pre-compute diffusion schedule
beta = torch.linspace(1e-4, 0.02, TIMESTEPS).to(DEVICE)
alpha = 1. - beta
alpha_hat = torch.cumprod(alpha, dim=0)

# --- 3. Diffusion Sampling Function ---
def sample_diffusion(model, condition_trajectory, n_samples):
    """
    Infers weights given a condition trajectory using the diffusion model.
    """
    model.eval()
    with torch.no_grad():
        # Replicate condition for the batch size
        cond_repeated = condition_trajectory.repeat(n_samples, 1, 1)
        
        # Start from pure Gaussian noise
        w_current = torch.randn(n_samples, W_DIM).to(DEVICE)

        # Denoising loop
        for i in reversed(range(TIMESTEPS)):
            t = torch.full((n_samples,), i, device=DEVICE, dtype=torch.long)
            predicted_noise = model(w_current, t, cond_repeated)

            alpha_t = alpha[i]
            alpha_hat_t = alpha_hat[i]
            beta_t = beta[i]

            if i > 0:
                noise = torch.randn_like(w_current)
            else:
                noise = torch.zeros_like(w_current)

            # Reverse diffusion step
            w_current = (1 / torch.sqrt(alpha_t)) * (
                w_current - ((1 - alpha_t) / torch.sqrt(1 - alpha_hat_t)) * predicted_noise
            ) + torch.sqrt(beta_t) * noise

    return w_current

# --- 4. Prepare Data for Inference ---
observation_length = MAX_LEN 
sub_traj = traj_true[:observation_length]

# Create padding and mask
padded_traj = np.zeros((MAX_LEN, 2))
padded_traj[:observation_length] = sub_traj
mask = np.zeros((MAX_LEN, 1))
mask[:observation_length] = 1

# Concatenate and convert to tensor
combined = np.concatenate([padded_traj, mask], axis=1)
traj_tensor = torch.FloatTensor(combined).unsqueeze(0).transpose(1, 2).to(DEVICE)

# --- 5. Run Inference ---
print("Running diffusion inference...")
generated_w_normalized = sample_diffusion(model, traj_tensor, N_SAMPLES)
generated_w = scaler_w.inverse_transform(generated_w_normalized.cpu().numpy())

# Calculate the MEAN predicted weight
w_pred_mean = np.mean(generated_w, axis=0)

# Optional: Normalize
if np.sum(w_pred_mean) > 0:
    w_pred_mean = w_pred_mean / np.sum(w_pred_mean)

print(f"Predicted Mean Weights: {w_pred_mean}")

# --- 6. Reconstruct Trajectory ---
print("Solving OCP with predicted weights to reconstruct trajectory...")
try:
    traj_reconstructed, _ = solve_DOC(w_pred_mean, x_fin=-1.0, q_init=np.array([0, np.pi/4]))
except Exception as e:
    print(f"Error solving OCP for reconstruction: {e}")
    traj_reconstructed = np.zeros_like(traj_true)

# --- 7. Plotting Results (Separated) ---
# We create a figure with 3 columns
fig, (ax_w, ax_q1, ax_q2) = plt.subplots(1, 3, figsize=(18, 6))

# --- Plot 1: Weights Comparison ---
indices = np.arange(W_DIM)
width = 0.35
ax_w.bar(indices - width/2, w_true, width, label='True Weights', color='black', alpha=0.7)
ax_w.bar(indices + width/2, w_pred_mean, width, label='Predicted (Mean)', color='orange', alpha=0.7)
ax_w.set_ylabel('Weight Value')
ax_w.set_title('Weights Comparison')
ax_w.set_xticks(indices)
ax_w.set_xticklabels([f'w{i+1}' for i in indices])
ax_w.legend()
ax_w.grid(True, linestyle='--', alpha=0.3)

# --- Plot 2: Trajectory q1 (Shoulder/First Joint) ---
time_steps = np.arange(MAX_LEN)
ax_q1.plot(traj_true[:, 0], 'k--', linewidth=2, label='q1 True')
ax_q1.plot(traj_reconstructed[:, 0], 'b-', linewidth=2, alpha=0.8, label='q1 Reconstructed')
ax_q1.set_title('Joint Angle q1 Reconstruction')
ax_q1.set_xlabel('Time Step')
ax_q1.set_ylabel('Angle (rad)')
ax_q1.legend()
ax_q1.grid(True, linestyle='--', alpha=0.3)

# --- Plot 3: Trajectory q2 (Elbow/Second Joint) ---
ax_q2.plot(traj_true[:, 1], 'k--', linewidth=2, label='q2 True')
ax_q2.plot(traj_reconstructed[:, 1], 'r-', linewidth=2, alpha=0.8, label='q2 Reconstructed')
ax_q2.set_title('Joint Angle q2 Reconstruction')
ax_q2.set_xlabel('Time Step')
ax_q2.set_ylabel('Angle (rad)')
ax_q2.legend()
ax_q2.grid(True, linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()

# Save the figure
fig.savefig("reconstruction_separated.png")
print("Comparison plot saved as 'reconstruction_separated.png'")